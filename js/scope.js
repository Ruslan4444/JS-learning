// Область видимості
// Область видимості (scope) - механізм, який визначає доступність змінних у коді, що виконується.

// Ланцюжок областей видимості (scope chain) - області видимості утворюють ієрархію, за якою дочірні області мають доступ до змінних з батьківських областей, але не навпаки.

// Змінні, оголошені на найвищому рівні, тобто за межами будь-яких конструкцій на зразок if, while, for і функцій, знаходяться в глобальній області видимості і доступні всюди після їх оголошення.
const globalValue = 10;

console.log(globalValue); // 10

function foo() {
  console.log(globalValue); // 10
}

for (let i = 0; i < 5; i++) {
  console.log(globalValue); // 10

  if (i === 2) {
    console.log(globalValue); // 10
  }
}

// Змінні, оголошені всередині інструкцій if, for, функцій та інших блоків коду, взятих у фігурні дужки {}, знаходяться в блоковій області видимості і доступні тільки всередині цього блоку коду або у блоках, вкладених в нього.
function foo1() {
  const a = 20;
  console.log(a); // 20

  for (let i = 0; i < 5; i++) {
    console.log(a); // 20

    if (i === 2) {
      console.log(a); // 20
    }
  }
}
foo1();
// ❌ Помилка! Змінна a - недоступна у глобальній області видимості
// console.log(a);

for (let i = 0; i < 3; i++) {
  // ❌ Помилка! Змінна a - недоступна в цій області видимості
  //   console.log(a);
}

for (let i = 0; i < 5; i++) {
  const a = 20;
  console.log(a); // 20

  if (i === 2) {
    const b = 30;
    console.log(a); // 20
    console.log(b); // 30
  }

  if (i === 3) {
    console.log(a); // 20

    // ❌ Помилка! Змінна b - недоступна в цій області видимості
    // console.log(b);
  }
}

// Стек викликів
function fnA() {
  console.log('Лог всередині функції fnA до виклику fnB'); //2
  fnB();
  console.log('Лог всередині функції fnA після виклику fnB'); //4
}

function fnB() {
  console.log('Лог всередині функції fnB'); //3
}

console.log('Лог до виклику fnA'); //1
fnA();
console.log('Лог після виклику fnA'); //5

// "Лог до виклику fnA"
// "Лог всередині функції fnA до виклику fnB"
// "Лог всередині функції fnB"
// "Лог всередині функції fnA після виклику fnB"
// "Лог після виклику fnA"

// Стек
// Стек - структура даних, яка працює за принципом LIFO (Last-In-First-Out), тобто останнім прийшов - першим пішов. Останнє, що додається у стек, буде видалено з нього першим, - тому можна додати або видалити елементи тільки з верхівки стека.

// Уявіть стек у вигляді масиву, у якого є тільки методи pop і push, тобто можна додати або видалити тільки елемент в кінці колекції.
// Stack frame (кадр стека, запис стека) - структура, яка додається у стек на момент виклику функції. Зберігає службову інформацію, наприклад, ім'я функції і номер рядка, в якому був виклик.

function bar() {
  console.log('bar');
}

function baz() {
  console.log('baz');
}

function foo2() {
  console.log('foo');
  bar();
  baz();
}

foo2();

// Переповнення стека викликів
// Стек викликів - не безмежний, йому відводиться кінцевий об'єм пам'яті. Іноді в консолі можна побачити помилку "Uncaught RangeError: Maximum call stack size exceeded" - переповнення стека (stack overflow).
